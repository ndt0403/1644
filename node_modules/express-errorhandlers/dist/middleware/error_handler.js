"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const accepts_1 = __importDefault(require("accepts"));
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const pug_1 = __importDefault(require("pug"));
const log = debug_1.default('express-errorhandler:error_handler');
const handler_1 = __importDefault(require("../handler"));
// const TYPE_TEXT = 'text';
const TYPE_JSON = 'json';
const TYPE_HTML = 'html';
const SUPPORT_TYPES = [TYPE_JSON, TYPE_HTML];
/**
 * Multi Error Handler
 */
exports.default = (options = {}) => {
    log('options=%O', options);
    const debug = !!options.debug;
    const templateHTML = options.templateHTML || path_1.default.join(__dirname, '../views/html/layout.pug');
    const templateHTMLOptions = options.templateHTMLOptions;
    const templateTEXT = options.templateTEXT || path_1.default.join(__dirname, '../views/text/layout.pug');
    const templateTEXTOptions = options.templateTEXTOptions;
    let compileHTML;
    let compileText;
    try {
        fs_1.default.statSync(templateHTML);
        fs_1.default.statSync(templateTEXT);
        compileHTML = pug_1.default.compileFile(templateHTML, templateHTMLOptions);
        compileText = pug_1.default.compileFile(templateTEXT, templateTEXTOptions);
    }
    catch (e) {
        compileHTML = pug_1.default.compile(templateHTML, templateHTMLOptions);
        compileText = pug_1.default.compile(templateTEXT, templateTEXTOptions);
    }
    const status = options.status;
    const message = options.message;
    const extra = options.extra;
    const extraDebug = options.extraDebug;
    const final = options.final;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return (err, req, res, _next) => {
        let handler;
        if (!(err instanceof handler_1.default)) {
            handler = new handler_1.default(err, status, message, extra, extraDebug);
        }
        else {
            handler = err;
        }
        const data = handler.toData();
        const accept = accepts_1.default(req);
        switch (accept.type(SUPPORT_TYPES)) {
            case TYPE_JSON: {
                const ret = {
                    request: {},
                    response: {
                        extra: data.extra,
                        extraDebug: {},
                        message: data.message,
                        stack: '',
                        status: data.status,
                    },
                };
                if (debug) {
                    ret.request = {
                        accessurl: `${req.protocol}://${req.get('host')}${req.originalUrl}`,
                        headers: req.headers,
                        hostname: req.hostname,
                        httpVersion: req.httpVersion,
                        ip: req.ip,
                        ips: req.ips,
                        method: req.method,
                        originalUrl: req.originalUrl,
                        params: req.params,
                        path: req.path,
                        protocol: req.protocol,
                        query: req.query,
                        url: req.url,
                    };
                    ret.response.stack = data.stack;
                    ret.response.extraDebug = data.extraDebug;
                }
                res.status(handler.status).json(ret);
                break;
            }
            case TYPE_HTML: {
                const html = compileHTML({
                    data,
                    debug,
                    req,
                    res,
                });
                res
                    .status(data.status)
                    .set('Content-Type', 'text/html')
                    .write(html);
                break;
            }
            default: {
                const text = compileText({
                    data,
                    debug,
                    req,
                    res,
                });
                res
                    .status(data.status)
                    .set('Content-Type', 'text/plain')
                    .write(text);
                break;
            }
        }
        log('%O', {
            request: {
                accessurl: `${req.protocol}://${req.get('host')}${req.originalUrl}`,
                headers: req.headers,
                hostname: req.hostname,
                httpVersion: req.httpVersion,
                ip: req.ip,
                ips: req.ips,
                method: req.method,
                originalUrl: req.originalUrl,
                params: req.params,
                path: req.path,
                protocol: req.protocol,
                query: req.query,
                url: req.url,
            },
            response: data,
        });
        ///
        res.end();
        if (final) {
            final(req, res, handler);
        }
    };
};
//# sourceMappingURL=error_handler.js.map